library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity maxFinder is
  generic (
    numInput   : integer := 10;  -- 輸入筆數（例如 10）
    inputWidth : integer := 16   -- 每筆寬度（例如 16-bit）
  );
  port (
    i_clk       : in  std_logic;
    i_data      : in  std_logic_vector(numInput*inputWidth-1 downto 0); -- 展平的一條匯流排
    i_valid     : in  std_logic;                                        -- 此拍資料有效
    o_data      : out std_logic_vector(31 downto 0);                    -- 最大值的索引 (0..numInput-1)
    o_data_valid: out std_logic                                         -- 結果有效脈衝（1 拍）
  );
end entity maxFinder;

architecture rtl of maxFinder is
  -- 內部暫存
  signal maxValue      : unsigned(inputWidth-1 downto 0) := (others => '0');
  signal inDataBuffer  : std_logic_vector(numInput*inputWidth-1 downto 0) := (others => '0');
  signal counter       : integer range 0 to integer'high := 0;
  signal o_data_r      : unsigned(31 downto 0) := (others => '0');
  signal o_data_valid_r: std_logic := '0';
begin
  -- 對外輸出
  o_data       <= std_logic_vector(o_data_r);
  o_data_valid <= o_data_valid_r;

  process(i_clk)
    variable lo   : integer;
    variable hi   : integer;
    variable curr : unsigned(inputWidth-1 downto 0);
  begin
    if rising_edge(i_clk) then
      -- 預設本拍不輸出有效
      o_data_valid_r <= '0';

      if i_valid = '1' then
        -- 起始：拿第 0 筆當暫時最大，從第 1 筆開始逐拍比較
        maxValue     <= unsigned(i_data(inputWidth-1 downto 0));
        counter      <= 1;
        inDataBuffer <= i_data;
        o_data_r     <= (others => '0');  -- 目前最大索引 = 0

      elsif counter = numInput then
        -- 已比較完第 numInput-1 筆；這一拍拉高 valid 並收尾
        counter        <= 0;
        o_data_valid_r <= '1';

      elsif counter /= 0 then
        -- 比較進行中：這拍比較「舊 counter」那一筆
        lo   := counter * inputWidth;
        hi   := lo + inputWidth - 1;
        curr := unsigned(inDataBuffer(hi downto lo));  -- 若要有號比較改成 signed(...)

        if curr > maxValue then
          maxValue <= curr;
          o_data_r <= to_unsigned(counter, o_data_r'length);
        end if;

        counter <= counter + 1;
      end if;
    end if;
  end process;

end architecture rtl;