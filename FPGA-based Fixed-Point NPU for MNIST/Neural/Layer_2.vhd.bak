library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity Layer_2 is
  generic(
    NN            : integer := 30;          -- 本層 neuron 數
    numWeight     : integer := 30;          -- ← 這層的輸入向量長度=前一層的 NN
    dataWidth     : integer := 16;
    layerNum      : integer := 2;           -- 這層的 layer 編號（給 config 用）
    sigmoidSize   : integer := 5;
    weightIntWidth: integer := 1;
    actType       : string  := "sigmoid"
  );
  port(
    clk   : in  std_logic;
    rst   : in  std_logic;

    -- 權重/偏置（PRETRAINED=true 可不接）
    weightValid   : in  std_logic := '0';
    biasValid     : in  std_logic := '0';
    weightValue   : in  signed(31 downto 0) := (others=>'0');
    biasValue     : in  signed(31 downto 0) := (others=>'0');
    config_layer_num  : in unsigned(31 downto 0) := (others=>'0');
    config_neuron_num : in unsigned(31 downto 0) := (others=>'0');

    -- 串流輸入（來自 Layer_1 的 y_out/y_valid）
    x_in    : in  signed(dataWidth-1 downto 0);
    x_valid : in  std_logic;

    -- 串流輸出（送往 Layer_3）
    y_out    : out signed(dataWidth-1 downto 0);
    y_valid  : out std_logic
  );
end entity;

architecture rtl of Layer_2 is
  -- 內部平行匯流排
  type sarr_t is array (natural range <>) of signed(dataWidth-1 downto 0);
  signal y_bus : sarr_t(0 to NN-1);
  signal v_bus : std_logic_vector(NN-1 downto 0);

  signal x_out_flat : std_logic_vector(NN*dataWidth-1 downto 0);
  signal hold_reg   : std_logic_vector(NN*dataWidth-1 downto 0);
  signal send_cnt   : integer range 0 to NN := 0;

  type state_t is (IDLE, SEND);
  signal st : state_t := IDLE;

  -- 固定對應第二層的檔名（VHDL 合成友善：用 case）
  function weight_name(i: integer) return string is
  begin
    case i is
      when  0 => return "w_2_0.mif";
      when  1 => return "w_2_1.mif";
      when  2 => return "w_2_2.mif";
      when  3 => return "w_2_3.mif";
      when  4 => return "w_2_4.mif";
      when  5 => return "w_2_5.mif";
      when  6 => return "w_2_6.mif";
      when  7 => return "w_2_7.mif";
      when  8 => return "w_2_8.mif";
      when  9 => return "w_2_9.mif";
      when 10 => return "w_2_10.mif";
      when 11 => return "w_2_11.mif";
      when 12 => return "w_2_12.mif";
      when 13 => return "w_2_13.mif";
      when 14 => return "w_2_14.mif";
      when 15 => return "w_2_15.mif";
      when 16 => return "w_2_16.mif";
      when 17 => return "w_2_17.mif";
      when 18 => return "w_2_18.mif";
      when 19 => return "w_2_19.mif";
      when 20 => return "w_2_20.mif";
      when 21 => return "w_2_21.mif";
      when 22 => return "w_2_22.mif";
      when 23 => return "w_2_23.mif";
      when 24 => return "w_2_24.mif";
      when 25 => return "w_2_25.mif";
      when 26 => return "w_2_26.mif";
      when 27 => return "w_2_27.mif";
      when 28 => return "w_2_28.mif";
      when others => return "w_2_29.mif";
    end case;
  end function;

  function bias_name(i: integer) return string is
  begin
    case i is
      when  0 => return "b_2_0.mif";
      when  1 => return "b_2_1.mif";
      when  2 => return "b_2_2.mif";
      when  3 => return "b_2_3.mif";
      when  4 => return "b_2_4.mif";
      when  5 => return "b_2_5.mif";
      when  6 => return "b_2_6.mif";
      when  7 => return "b_2_7.mif";
      when  8 => return "b_2_8.mif";
      when  9 => return "b_2_9.mif";
      when 10 => return "b_2_10.mif";
      when 11 => return "b_2_11.mif";
      when 12 => return "b_2_12.mif";
      when 13 => return "b_2_13.mif";
      when 14 => return "b_2_14.mif";
      when 15 => return "b_2_15.mif";
      when 16 => return "b_2_16.mif";
      when 17 => return "b_2_17.mif";
      when 18 => return "b_2_18.mif";
      when 19 => return "b_2_19.mif";
      when 20 => return "b_2_20.mif";
      when 21 => return "b_2_21.mif";
      when 22 => return "b_2_22.mif";
      when 23 => return "b_2_23.mif";
      when 24 => return "b_2_24.mif";
      when 25 => return "b_2_25.mif";
      when 26 => return "b_2_26.mif";
      when 27 => return "b_2_27.mif";
      when 28 => return "b_2_28.mif";
      when others => return "b_2_29.mif";
    end case;
  end function;

begin
  -- NN 顆 neuron（注意：埠名用你的 VHDL 定義）
  genN : for i in 0 to NN-1 generate
  begin
    N_I : entity work.neuron
      generic map(
        layerNo        => layerNum,
        neuronNo       => i,
        numWeight      => numWeight,
        dataWidth      => dataWidth,
        sigmoidSize    => sigmoidSize,
        weightIntWidth => weightIntWidth,
        actType        => actType,
        weightFile     => weight_name(i),
        biasFile       => bias_name(i)
      )
      port map(
        clk   => clk,
        rst   => rst,
        myinput        => x_in,
        myinputValid   => x_valid,
        weightValid    => weightValid,
        biasValid      => biasValid,
        weightValue    => weightValue,
        biasValue      => biasValue,
        config_layer_num  => config_layer_num,
        config_neuron_num => config_neuron_num,
        output   => y_bus(i),
        outvalid => v_bus(i)
      );
  end generate;

  -- 打包成一條大向量（只在本層內）
  pack_bus : for i in 0 to NN-1 generate
  begin
    x_out_flat( (i+1)*dataWidth-1 downto i*dataWidth ) <= std_logic_vector(y_bus(i));
  end generate;

  -- FSM：抓到 valid（任選一個位元；這裡用 v_bus(0)）→ 鎖進 hold_reg → 逐拍序列送出
  process(clk)
  begin
    if rising_edge(clk) then
      if rst='1' then
        st       <= IDLE;
        hold_reg <= (others=>'0');
        send_cnt <= 0;
        y_out    <= (others=>'0');
        y_valid  <= '0';
      else
        case st is
          when IDLE =>
            y_valid <= '0';
            if v_bus(0) = '1' then
              hold_reg <= x_out_flat;
              send_cnt <= 0;
              st <= SEND;
            end if;

          when SEND =>
            y_out   <= signed( hold_reg(dataWidth-1 downto 0) );
            y_valid <= '1';
            hold_reg <= hold_reg(hold_reg'high downto dataWidth) & (dataWidth-1 downto 0 => '0');

            if send_cnt = NN-1 then
              st <= IDLE;
              y_valid <= '0';
            else
              send_cnt <= send_cnt + 1;
            end if;
        end case;
      end if;
    end if;
  end process;

end architecture;