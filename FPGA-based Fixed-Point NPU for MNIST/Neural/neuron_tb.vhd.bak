library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity neuron_tb is end;
architecture sim of neuron_tb is
  constant T : time := 5 ns;

  signal clk           : std_logic := '0';
  signal rst           : std_logic := '1';

  signal myinput       : std_logic_vector(15 downto 0) := (others=>'0');
  signal myinputValid  : std_logic := '0';

  -- 這些在 PRETRAINED 模式下都綁 0 就好
  signal weightValid        : std_logic := '0';
  signal biasValid          : std_logic := '0';
  signal weightValue        : std_logic_vector(31 downto 0) := (others=>'0');
  signal biasValue          : std_logic_vector(31 downto 0) := (others=>'0');
  signal config_layer_num   : std_logic_vector(31 downto 0) := (others=>'0');
  signal config_neuron_num  : std_logic_vector(31 downto 0) := (others=>'0');

  signal output        : std_logic_vector(15 downto 0);
  signal outvalid      : std_logic;

begin
  clk <= not clk after T/2;

  -- 單顆 neuron，numWeight=4，先用 ReLU 確認乘加路徑沒 U
  dut: entity work.neuron
    generic map(
      layerNo        => 1,
      neuronNo       => 0,
      numWeight      => 4,                  -- ★只喂 4 筆
      dataWidth      => 16,
      sigmoidSize    => 5,
      weightIntWidth => 1,
      actType        => "relu",             -- ★先避開 sigmoid
      biasFile       => "C:/VHDL_training/Neural/b_tb.mif",
      weightFile     => "C:/VHDL_training/Neural/w_tb.mif"
    )
    port map(
      clk               => clk,
      rst               => rst,
      myinput           => myinput,
      myinputValid      => myinputValid,
      weightValid       => weightValid,
      biasValid         => biasValid,
      weightValue       => weightValue,
      biasValue         => biasValue,
      config_layer_num  => config_layer_num,
      config_neuron_num => config_neuron_num,
      output            => output,
      outvalid          => outvalid
    );

  -- 刺激：reset -> 連續 4 拍 valid 並送 1,2,3,4
  stim: process
  begin
    rst <= '1'; myinputValid <= '0'; myinput <= (others=>'0');
    wait for 20*T; rst <= '0'; wait for 5*T;

    for i in 0 to 3 loop
      myinput      <= std_logic_vector(to_signed(i+1, 16));  -- 1,2,3,4
      myinputValid <= '1';
      wait until rising_edge(clk);
    end loop;
    myinputValid <= '0';
    myinput      <= (others=>'0');

    wait for 200 ns;
    std.env.stop;
    wait;
  end process;
end architecture;