library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity mac_int8 is
	generic(acc_width: integer:=32;
			  sat_en: boolean: false
			 );
	port(clk :in std_logic;
		  rst_n :in std_logic;
		  a :in signed(7 downto 0);
		  b :in signed(7 down to 0);
		  acc_in :in signed(acc_width-1 downto 0);
		  en :in std_logic;
		  acc_out :out signed(acc_width-1 downto 0));
end entity mac_int8;

architecture rtl_code of mac_int8 is
	signal mult16 :signed(15 down to 0);
	signal mult_ext :signed(acc_width-1 downto 0);
	signal sum_w :signed(acc_width-1 downto 0);
	signal wide_sum :signed(acc_width downto 0);
	
	function 
	sat(x :signed(acc_width-1 downto 0);
		 wide_x :signed(acc_width downto 0)) return signed is
	variable y :signed(acc_width-1 downto 0);
	
	begin
		if not sat_en then
			return x;
		end if;
		
		if wide_x(acc_width) /= wide_x(acc_width - 1) then
			if wide_x(acc_width) = '1' then
				y := to_signed((-2**(acc_width-1)), acc_width);
			else 
				y := to_signed(2**(acc_width-1) -1, acc_width);
			end if;
			return y;
		else
			return x;
		end if;	
	end function;
	--multiply
	mult16 <= a *b;
	mult_ext <= resize(mult16, acc_width);
	sum_w <= acc_in + mul_ext;
	wide_sum <= resize(acc_in, acc_width+1) + resize(mul_ext, acc_width+1);
	process(clk, rst_n)
		variable next_acc :signed(acc_width-1 downto 0);
	begin
		if (rst_n) = '0' then
			acc_out <= (others => '0');
			else 
			if rising_edge(clk) then
				if en = '1' then
					next_acc := sat(sum_w, wide_sum);
					acc_out <= next_acc;
				else
					acc_out <= acc_in;
				end if;
			end if;
		end if;
	end process;
end architecture rtl_code;